"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const process_1 = __importDefault(require("process"));
const allure_js_commons_1 = require("allure-js-commons");
const internal_1 = require("allure-js-commons/internal");
const utils_1 = require("./utils");
class AllureReporter {
    constructor(options = { suiteTitle: true, detail: true }) {
        this.allureWriter = process_1.default.env.PW_ALLURE_POST_PROCESSOR_FOR_TEST
            ? new allure_js_commons_1.MessageAllureWriter()
            : undefined;
        this.allureGroupCache = new Map();
        this.allureTestCache = new Map();
        this.allureStepCache = new Map();
        this.hostname = process_1.default.env.ALLURE_HOST_NAME || os_1.default.hostname();
        this.globalStartTime = new Date();
        this.processedDiffs = [];
        this.options = options;
    }
    onBegin(config, suite) {
        this.config = config;
        this.suite = suite;
        this.resultsDir = (0, allure_js_commons_1.allureReportFolder)(this.options.outputFolder);
        this.allureRuntime = new allure_js_commons_1.AllureRuntime({
            resultsDir: this.resultsDir,
            writer: this.allureWriter,
        });
    }
    onTestBegin(test) {
        const suite = test.parent;
        const group = this.ensureAllureGroupCreated(suite);
        const allureTest = group.startTest(test.title);
        allureTest.addLabel(allure_js_commons_1.LabelName.LANGUAGE, "JavaScript");
        allureTest.addLabel(allure_js_commons_1.LabelName.FRAMEWORK, "Playwright");
        const titleMetadata = (0, utils_1.extractMetadataFromString)(test.title);
        titleMetadata.labels.forEach((label) => allureTest.addLabel(label.name, label.value));
        const [, projectSuiteTitle, fileSuiteTitle, ...suiteTitles] = suite.titlePath();
        allureTest.addLabel("titlePath", suite.titlePath().join(" > "));
        if (projectSuiteTitle) {
            allureTest.addLabel(allure_js_commons_1.LabelName.PARENT_SUITE, projectSuiteTitle);
        }
        if (this.options.suiteTitle && fileSuiteTitle) {
            allureTest.addLabel(allure_js_commons_1.LabelName.SUITE, fileSuiteTitle);
        }
        if (suiteTitles.length > 0) {
            allureTest.addLabel(allure_js_commons_1.LabelName.SUB_SUITE, suiteTitles.join(" > "));
        }
        const project = suite.project();
        if (project.name) {
            allureTest.addParameter("Project", project.name);
        }
        if (project.repeatEach > 1) {
            allureTest.addParameter("Repetition", `${test.repeatEachIndex + 1}`);
        }
        const relativeFile = path_1.default
            .relative(project === null || project === void 0 ? void 0 : project.testDir, test.location.file)
            .split(path_1.default.sep)
            .join("/");
        const nameSuites = suiteTitles.length > 0 ? `${suiteTitles.join(" ")} ` : "";
        const fullName = `${relativeFile}#${nameSuites}${test.title}`;
        const testCaseIdSource = `${relativeFile}#${test.title}`;
        allureTest.fullName = fullName;
        allureTest.testCaseId = (0, allure_js_commons_1.md5)(testCaseIdSource);
        this.allureTestCache.set(test, allureTest);
    }
    onStepBegin(test, _result, step) {
        const allureTest = this.allureTestCache.get(test);
        if (!allureTest) {
            return;
        }
        if (!this.options.detail && step.category !== "test.step") {
            return;
        }
        this.ensureAllureStepCreated(step, allureTest);
    }
    onStepEnd(_test, _result, step) {
        const allureStep = this.allureStepCache.get(step);
        if (!allureStep) {
            return;
        }
        if (!this.options.detail && step.category !== "test.step") {
            return;
        }
        allureStep.endStep();
        allureStep.status = step.error ? allure_js_commons_1.Status.FAILED : allure_js_commons_1.Status.PASSED;
        if (step.error) {
            allureStep.statusDetails = getStatusDetails(step.error);
        }
    }
    async onTestEnd(test, result) {
        var _a, _b, _c, _d;
        const runtime = this.getAllureRuntime();
        const allureTest = this.allureTestCache.get(test);
        if (!allureTest) {
            return;
        }
        const threadId = result.parallelIndex !== undefined ? result.parallelIndex : result.workerIndex;
        const thread = process_1.default.env.ALLURE_THREAD_NAME ||
            `${this.hostname}-${process_1.default.pid}-playwright-worker-${threadId}`;
        allureTest.addLabel(allure_js_commons_1.LabelName.HOST, this.hostname);
        allureTest.addLabel(allure_js_commons_1.LabelName.THREAD, thread);
        allureTest.status = statusToAllureStats(result.status, test.expectedStatus);
        const error = result.error;
        if (error) {
            allureTest.statusDetails = getStatusDetails(error);
        }
        for (const attachment of result.attachments) {
            if (!attachment.body && !attachment.path) {
                continue;
            }
            if (attachment.contentType === internal_1.ALLURE_METADATA_CONTENT_TYPE) {
                if (!attachment.body) {
                    continue;
                }
                const metadata = JSON.parse(attachment.body.toString());
                (_a = metadata.links) === null || _a === void 0 ? void 0 : _a.forEach((val) => allureTest.addLink(val.url, val.name, val.type));
                (_b = metadata.labels) === null || _b === void 0 ? void 0 : _b.forEach((val) => allureTest.addLabel(val.name, val.value));
                (_c = metadata.parameter) === null || _c === void 0 ? void 0 : _c.forEach((val) => allureTest.addParameter(val.name, val.value, {
                    excluded: val.excluded,
                    mode: val.mode,
                }));
                if (metadata.description) {
                    allureTest.description = metadata.description;
                }
                continue;
            }
            let fileName;
            if (attachment.body) {
                fileName = runtime.writeAttachment(attachment.body, attachment.contentType);
            }
            else {
                if (!fs_1.default.existsSync(attachment.path)) {
                    continue;
                }
                fileName = runtime.writeAttachmentFromPath(attachment.path, attachment.contentType);
            }
            const diffEndRegexp = /-((expected)|(diff)|(actual))\.png$/;
            if (attachment.name.match(diffEndRegexp)) {
                const pathWithoutEnd = attachment.path.replace(diffEndRegexp, "");
                if (this.processedDiffs.includes(pathWithoutEnd)) {
                    continue;
                }
                const actualBase64 = await (0, allure_js_commons_1.readImageAsBase64)(`${pathWithoutEnd}-actual.png`), expectedBase64 = await (0, allure_js_commons_1.readImageAsBase64)(`${pathWithoutEnd}-expected.png`), diffBase64 = await (0, allure_js_commons_1.readImageAsBase64)(`${pathWithoutEnd}-diff.png`);
                const diffName = attachment.name.replace(diffEndRegexp, "");
                const res = (_d = this.allureRuntime) === null || _d === void 0 ? void 0 : _d.writeAttachment(JSON.stringify({
                    expected: expectedBase64,
                    actual: actualBase64,
                    diff: diffBase64,
                    name: diffName,
                }), { contentType: internal_1.ALLURE_IMAGEDIFF_CONTENT_TYPE, fileExtension: "imagediff" });
                allureTest.addAttachment(diffName, { contentType: internal_1.ALLURE_IMAGEDIFF_CONTENT_TYPE }, res);
                this.processedDiffs.push(pathWithoutEnd);
            }
            else {
                allureTest.addAttachment(attachment.name, attachment.contentType, fileName);
            }
        }
        if (result.stdout.length > 0) {
            allureTest.addAttachment("stdout", "text/plain", runtime.writeAttachment((0, allure_js_commons_1.stripAscii)(result.stdout.join("")), "text/plain"));
        }
        if (result.stderr.length > 0) {
            allureTest.addAttachment("stderr", "text/plain", runtime.writeAttachment((0, allure_js_commons_1.stripAscii)(result.stderr.join("")), "text/plain"));
        }
        allureTest.calculateHistoryId();
        allureTest.endTest();
    }
    addSkippedResults() {
        const unprocessedCases = this.suite
            .allTests()
            .filter((testCase) => !this.allureTestCache.has(testCase));
        unprocessedCases.forEach((testCase) => {
            this.onTestBegin(testCase);
            const allureTest = this.allureTestCache.get(testCase);
            if (allureTest) {
                allureTest.addLabel(allure_js_commons_1.LabelName.ALLURE_ID, "-1");
                allureTest.detailsMessage =
                    "This test was skipped due to test setup error. Check you setup scripts to fix the issue.";
            }
            this.onTestEnd(testCase, {
                status: allure_js_commons_1.Status.SKIPPED,
                attachments: [],
                duration: 0,
                errors: [],
                parallelIndex: 0,
                workerIndex: 0,
                retry: 0,
                steps: [],
                stderr: [],
                stdout: [],
                startTime: this.globalStartTime,
            });
        });
    }
    onEnd() {
        var _a, _b, _c;
        this.addSkippedResults();
        for (const group of this.allureGroupCache.values()) {
            group.endGroup();
        }
        if (this.options.environmentInfo) {
            (_a = this.allureRuntime) === null || _a === void 0 ? void 0 : _a.writeEnvironmentInfo((_b = this.options) === null || _b === void 0 ? void 0 : _b.environmentInfo);
        }
        if (this.options.categories) {
            (_c = this.allureRuntime) === null || _c === void 0 ? void 0 : _c.writeCategoriesDefinitions(this.options.categories);
        }
    }
    printsToStdio() {
        return false;
    }
    getAllureRuntime() {
        if (!this.allureRuntime) {
            throw new Error("Unexpected state: `allureRuntime` is not initialized");
        }
        return this.allureRuntime;
    }
    ensureAllureGroupCreated(suite) {
        let group = this.allureGroupCache.get(suite);
        if (!group) {
            const parent = suite.parent
                ? this.ensureAllureGroupCreated(suite.parent)
                : this.getAllureRuntime();
            group = parent.startGroup(suite.title);
            this.allureGroupCache.set(suite, group);
        }
        return group;
    }
    ensureAllureStepCreated(step, allureTest) {
        let allureStep = this.allureStepCache.get(step);
        if (!allureStep) {
            const parent = step.parent
                ? this.ensureAllureStepCreated(step.parent, allureTest)
                : allureTest;
            allureStep = parent.startStep(step.title);
            this.allureStepCache.set(step, allureStep);
        }
        return allureStep;
    }
}
const statusToAllureStats = (status, expectedStatus) => {
    if (status === "skipped") {
        return allure_js_commons_1.Status.SKIPPED;
    }
    if (status === "timedOut") {
        return allure_js_commons_1.Status.BROKEN;
    }
    if (status === expectedStatus) {
        return allure_js_commons_1.Status.PASSED;
    }
    return allure_js_commons_1.Status.FAILED;
};
exports.default = AllureReporter;
const appendStep = (parent, step) => {
    const allureStep = parent.startStep(step.title, step.startTime.getTime());
    allureStep.endStep(step.startTime.getTime() + step.duration);
    allureStep.status = step.error ? allure_js_commons_1.Status.FAILED : allure_js_commons_1.Status.PASSED;
    for (const child of step.steps || []) {
        appendStep(allureStep, child);
    }
};
const getStatusDetails = (error) => {
    const message = error.message && (0, allure_js_commons_1.stripAscii)(error.message);
    let trace = error.stack && (0, allure_js_commons_1.stripAscii)(error.stack);
    if (trace && message && trace.startsWith(`Error: ${message}`)) {
        trace = trace.substr(message.length + "Error: ".length);
    }
    return {
        message,
        trace,
    };
};
__exportStar(require("./helpers"), exports);
//# sourceMappingURL=index.js.map